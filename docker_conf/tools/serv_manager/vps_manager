#!/bin/bash
# Should be runned by systemd with network dependency and fail to mail

#TODO user external conf file ($1) to  get those values
FAIL_MAIL=[address@here.com]
LOCKFILE="/var/run/$(basename "$0").lock"
INTERVAL="15m"
MAX_FAIL_SCORE=2
HEALTHCHECK_SAFE_TIME="2m"
LOCAL_DIR=$(dirname "$(readlink -f "$0")")

MAIL_SERVER_FAIL_SCORE=0
NGINX_CERTBOT_FAIL_SCORE=0
VAULTWARDEN_FAIL_SCORE=0
GITEA_FAIL_SCORE=0

safe_exit() {
    echo "$1"
    rm -f "$LOCKFILE"
    exit "$2"
}

inspect() {
    docker inspect -f '{{.State.Status}}' $1 | grep -P "^running$" &>/dev/null && docker inspect -f '{{.State.Health.Status}}' $1 | grep -P "(^healthy$)" &>/dev/null
}

send_mail() {
    local message=`journalctl -eb CONTAINER_NAME=$1`
    echo -e "Subject:$1 Failure $2\n$message" | msmtp -a main $FAIL_MAIL
    if [ $? -ne 0 ]; then
        echo "Mail to $FAIL_MAIL failed, relaying on backup."
        echo -e "Subject:$1 Failure $2\n$message" | msmtp -a backup $FAIL_MAIL
    else
        echo "Mail sended to $FAIL_MAIL"
    fi
}

refresh_score() {
    # $1 cont name / $2 score
    if inspect $1; then
        echo 0
    elif [ $2 -lt $MAX_FAIL_SCORE ] ; then
        echo $(( $2 + 1 ))
    else
        echo $2
    fi
}

kill_handler() {
    safe_exit "KILL catched, exiting." 0
}

terminator() {
    kill -9 $1 1>/dev/null
    [ -f "$LOCKFILE" ] && ps -p $(cat "$LOCKFILE") > /dev/null && echo "Can't kill $1, exiting." && exit 1
}

check_lock()  {
    [ -f "$LOCKFILE" ] && ps -p $(cat "$LOCKFILE") > /dev/null && echo "$(basename "$0") is already running, restarting." && terminator $(cat "$LOCKFILE")
    echo $$ > "$LOCKFILE"
}

error_handler() {
    echo "$1 failed ($2)."
    send_mail $1 $2
    cd $LOCAL_DIR && cd ../..
    docker stop $1 &>/dev/null && echo "$1 stopped."
    $1/docker-run.sh default
}

check_loop() {
    while true;
    do
        sleep $INTERVAL

        local TMP=`refresh_score "mail_server" $MAIL_SERVER_FAIL_SCORE`
        [ $TMP -gt $MAIL_SERVER_FAIL_SCORE ] && error_handler "mail_server" $TMP
        MAIL_SERVER_FAIL_SCORE=$TMP

        local TMP2=`refresh_score "nginx_certbot" $NGINX_CERTBOT_FAIL_SCORE`
        [ $TMP2 -gt $NGINX_CERTBOT_FAIL_SCORE ] && error_handler "nginx_certbot" $TMP2
        NGINX_CERTBOT_FAIL_SCORE=$TMP2

        local TMP3=`refresh_score "vaultwarden" $VAULTWARDEN_FAIL_SCORE`
        [ $TMP3 -gt $VAULTWARDEN_FAIL_SCORE ] && error_handler "vaultwarden" $TMP3
        VAULTWARDEN_FAIL_SCORE=$TMP3
    done
}

docker_start() {
    cd $LOCAL_DIR && cd ../..
    for cont in "$@"
    do
        $cont/docker-run.sh default
    done
}

docker_stop() {
    for cont in "$@"
    do
        docker stop $cont 1>/dev/null && echo "$cont stopped."
    done
}

start() {
    #TODO user external conf file ($1) to  get those values
    docker_start mail_server nginx_certbot vaultwarden
    check_loop
}

stop() {
    #TODO user external conf file ($1) to  get those values
    docker_stop mail_server nginx_certbot vaultwarden
}

reload() {
    stop
    start
}

main() {
    [ `id -u` -ne 0 ] && echo "Must be run as root" && exit 1
    check_lock
    trap term_handler SIGKILL
    case $1 in
        start)  start;;
        reload) reload;;
        stop) stop;;
        * ) echo "USAGE: $(basename "$0") start|stop|reload";;
    esac
    safe_exit "$(basename "$0") exiting." 0
}

main $1
