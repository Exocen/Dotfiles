#!/usr/bin/python3
# Needed : mutagen, youtube_dl, ffmpeg
import mutagen

import re
import csv
import subprocess
import logging
import shutil
import json

from random import seed, randint
from time import sleep
from mutagen.easyid3 import EasyID3
from time import time
from os import path, listdir, utime
from tempfile import TemporaryDirectory

logging.basicConfig(level=logging.DEBUG)
log = logging.getLogger("YDL")
tmp_dir = "/var/tmp"
post_dl_cooldown = 15
error_cooldown = 60
loop_cooldown = 600
docker_data_path = "/ydl/"
params_location = path.join(docker_data_path, "ydl_param.csv")
DEFAULT_USAGE = f"multiline csv file usage -> output_dir (can use host:/), playlist_id, file_format(mp4,mkv,mp3) to {params_location}"
safe_fail_count = 0
retry_counter_max = 2
FORMATS = ["mp4", "mkv", "mp3"]
db_path = path.join(docker_data_path, "db.json")


class CmdException(Exception):
    pass


class Main:
    def __init__(self):
        self.playlist_id = None
        self.playlist_path_location = None
        self.params_list = self.get_param_list()
        log.debug(f"Using new parameters -> {self.params_list}")
        self.retry_counter = {}
        self.db = {}
        self.loop = True
        self.file_format = None

    def get_title_list(self, file_path):
        log.debug(f"getting titles from {file_path}")
        if path.exists(file_path):
            with open(file_path, newline="") as f:
                reader = csv.reader(f)
                return list(reader)[0]
        else:
            return []

    def write_title_list(self, file_path, title_list):
        # TODO REM csv
        log.info(f"writing titles to {file_path}")
        with open(file_path, "w", newline="") as csv_file:
            write = csv.writer(csv_file)
            write.writerow(title_list)

        with open(db_path, "w", newline="") as json_file:
            json_file.write(str(self.db))

    def get_param_list(self):
        rows = []
        if path.exists(params_location):
            with open(params_location, "r") as csvfile:
                csvreader = csv.reader(csvfile)
                # extracting each data row one by one
                for row in csvreader:
                    rows.append(row)
                return rows
        raise Exception(DEFAULT_USAGE)

    def get_filename_without_ext(self, filename):
        pre, ext = path.splitext(filename)
        if ext:
            return self.get_filename_without_ext(pre)
        else:
            return pre

    def connection_error(self, dl_error):
        self.retry_counter[self.playlist_id] = self.retry_counter[self.playlist_id] + 1
        if self.retry_counter[self.playlist_id] <= safe_fail_count:
            # Shit happen
            log.error(dl_error)
            Main.let_sleep(error_cooldown, True)
        elif self.retry_counter[self.playlist_id] < retry_counter_max:
            log.error(dl_error)
            log.info(
                f"Vpn reloading, {retry_counter_max - self.retry_counter[self.playlist_id]} tries left"
            )
            Main.run_process(
                [
                    "curl",
                    "-X",
                    "PUT",
                    "--fail",
                    "--silent",
                    "--show-error",
                    "http://localhost:8000/v1/openvpn/status",
                    "-H",
                    "Content-Type: application/json",
                    "-d",
                    '{"status":"stopped"}',
                ]
            )
            Main.run_process(
                [
                    "curl",
                    "-X",
                    "PUT",
                    "--fail",
                    "--silent",
                    "--show-error",
                    "http://localhost:8000/v1/openvpn/status",
                    "-H",
                    "Content-Type: application/json",
                    "-d",
                    '{"status":"running"}',
                ]
            )
            Main.let_sleep(error_cooldown, True)
        else:
            raise dl_error

    @staticmethod
    def run_process(cmd, islogging=True):
        s = subprocess.run(cmd, capture_output=True, text=True)
        if s.returncode != 0:
            raise CmdException(s.stderr)
        if s.stdout:
            if islogging:
                log.debug(s.stdout)
            return s.stdout
        return ""

    def dl_list(self, pid, tmpdirname):
        if self.file_format == "mp3":
            Main.run_process(
                [
                    "yt-dlp",
                    "--extract-audio",
                    "--audio-format",
                    self.file_format,
                    "-o",
                    tmpdirname + "/%(title)s",
                    pid,
                ]
            )
        elif self.file_format == "mp4":
            Main.run_process(
                [
                    "yt-dlp",
                    "-f",
                    "bestvideo[height<=?1080]",
                    "--recode-video",
                    self.file_format,
                    "-o",
                    tmpdirname + "/%(title)s.%(ext)s",
                    pid,
                ]
            )
        else:
            Main.run_process(
                [
                    "yt-dlp",
                    "--recode-video",
                    self.file_format,
                    "-o",
                    tmpdirname + "/%(title)s.%(ext)s",
                    pid,
                ]
            )

    def extract_info(self):
        try:
            cmd = ["yt-dlp", "--flat-playlist", "-J", self.playlist_id]
            return json.loads(Main.run_process(cmd, False))
        except Exception as extraction_error:
            self.connection_error(extraction_error)
            self.downloader()
            return

    def tag_and_copy(self, audio_data, tmpdirname):
        dest_path = path.join(
            self.playlist_path_location, audio_data.title + "." + self.file_format
        )
        filenames = listdir(tmpdirname)
        log.debug(f"files : {filenames}")
        if len(filenames) != 1:
            raise Exception(f"One file should be present: {filenames}")
        filepath = path.join(tmpdirname, filenames[0])
        # if artist and audio -> use id3 tags
        if self.file_format == "mp3" and audio_data.artist is not None:
            try:
                meta = EasyID3(filepath)
            except mutagen.id3.ID3NoHeaderError:
                meta = mutagen.File(filepath, easy=True)
                meta["title"] = audio_data.tagtitle
                meta["artist"] = audio_data.artist
                meta.save()
        current_time = time()
        utime(filepath, (current_time, current_time))
        shutil.move(filepath, dest_path)

    def downloader(self):
        log.debug("Checking playlist info (yt_dl)")
        infos = self.extract_info()

        playlist_title = infos["title"]
        file_list_path = path.join(docker_data_path, playlist_title + ".csv")

        # Check existing
        audio_data_list = []

        for info in infos["entries"]:
            audio_data_list.append(Audio_data(info["title"], info["id"]))

        existing_title_list = self.get_title_list(file_list_path)

        done_list = list(
            filter(
                lambda a: a in [b.title for b in audio_data_list], existing_title_list
            )
        )
        audio_data_list = list(
            filter(lambda a: a.title not in existing_title_list, audio_data_list)
        )

        # Dl and tag
        if audio_data_list:
            try:
                for audio_data in audio_data_list:
                    # new tmp dir every dl
                    with TemporaryDirectory(dir=tmp_dir) as tmpdirname:
                        log.info("Downloading: " + audio_data.title)
                        self.dl_list(audio_data.pid, tmpdirname)
                        log.debug("Tag and copy: " + audio_data.title)
                        self.tag_and_copy(audio_data, tmpdirname)
                        done_list.append(audio_data.title)
                        self.db[self.playlist_id] = done_list
                        self.write_title_list(file_list_path, done_list)
                        log.info("Downloaded: " + audio_data.title)
                        Main.let_sleep(post_dl_cooldown, True)

            except Exception as dl_error:
                self.connection_error(dl_error)
                self.downloader()
                return

        # Keep infos for next loop
        elif len(existing_title_list) != len(done_list):
            self.db[self.playlist_id] = done_list
            self.write_title_list(file_list_path, done_list)
            self.retry_counter[self.playlist_id] = 0

        # TODO REM
        self.db[self.playlist_id] = done_list
        self.write_title_list(file_list_path, done_list)

    def set_params(self, params):
        self.playlist_path_location = params[0]
        self.playlist_id = params[1]
        if self.playlist_id not in self.retry_counter:
            self.retry_counter[self.playlist_id] = 0
        if self.playlist_id not in self.db:
            self.db[self.playlist_id] = []
        if params[2].lower() in FORMATS:
            self.file_format = params[2].lower()
        else:
            raise Exception(DEFAULT_USAGE)

    @staticmethod
    def let_sleep(sleep_time, is_rnd=False):
        if is_rnd:
            sleep_time = sleep_time + randint(0, sleep_time)
        log.debug("Sleeping for " + str(sleep_time) + " second(s)")
        sleep(sleep_time)

    @staticmethod
    def check_dependencies():
        try:
            cmd = ["/usr/bin/ffmpeg", "-version"]
            Main.run_process(cmd, False)
            cmd = ["yt-dlp", "--version"]
            Main.run_process(cmd, False)
        except Exception as check_error:
            log.error(f"Missing dependency: {check_error}")
            exit(1)

    def run(self):
        log.info("YDL Starting...")
        Main.check_dependencies()
        seed()
        while self.loop:
            for params in self.params_list:
                self.set_params(params)
                self.downloader()
            Main.let_sleep(loop_cooldown, True)


class Audio_data:
    def __init__(self, title, pid):
        self.title = title
        self.pid = pid
        parsed_title = re.findall(r"(.*?)\s*(-|//)\s*(.*)", title)
        if len(parsed_title) > 0 and len(parsed_title[0]) == 3:
            self.artist = parsed_title[0][0]
            self.tagtitle = parsed_title[0][2]
        else:
            self.artist = None
            self.tagtitle = None


if __name__ == "__main__":
    Main().run()
